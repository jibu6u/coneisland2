<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VR Extrude Sequencer — Base 1 + Pieces 20 (Alternate)</title>
<style>
  :root{ --bg:#0b1220; --panel:#0f1722; --fg:#e6eef6; --muted:#9fb0c7; --accent:#4fc3ff; }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans;}
  #ui{position:fixed; left:12px; top:12px; width:390px; max-height:calc(100vh - 24px); overflow:auto; background:var(--panel); border:1px solid #173041; padding:12px; border-radius:10px; box-shadow:0 6px 18px #0009; z-index:60}
  label{display:block; font-size:13px; color:var(--muted); margin-top:8px}
  input[type=file]{width:100%}
  button{margin-top:8px; padding:8px 10px; border-radius:8px; border:none; cursor:pointer; font-weight:600}
  button.primary{background:linear-gradient(180deg,var(--accent),#0d8fb8); color:#05202b}
  button.ghost{background:#111827; color:#e6eef6; border:1px solid #24323f}
  .row{display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap}
  .small{font-size:12px; color:var(--muted)}
  #canvasContainer{width:100%; height:100vh; overflow:hidden}
  input[type=range]{width:220px}
  .sliderRow{display:flex; gap:8px; align-items:center}
  #piecesList{margin-top:8px; display:flex; flex-direction:column; gap:8px; max-height:260px; overflow:auto; padding:6px; border-radius:6px; background:#081018; border:1px solid #16202a}
  .pieceRow{display:flex; gap:8px; align-items:center; padding:6px; border-radius:8px; border:1px solid #20303f; background:#0a131c}
  .thumbSmall{width:56px; height:56px; object-fit:cover; background:#000; border-radius:6px; border:1px solid #20303f}
  .pieceMeta{flex:1; font-size:12px; color:var(--muted)}
  .pieceBtns{display:flex; gap:6px; align-items:center}
  .orderBadge{min-width:22px; text-align:center; font-weight:700; color:#05202b; background:linear-gradient(180deg,var(--accent),#0d8fb8); border-radius:6px; padding:2px 6px}
  #enterVrBtn{position:fixed; right:12px; bottom:12px; z-index:61; padding:10px 12px; border-radius:8px; background:linear-gradient(180deg,var(--accent),#0d8fb8); color:#05202b; font-weight:700; cursor:pointer; border:none}
  .webxr-button { position: fixed !important; right:12px !important; bottom:72px !important; z-index:62 !important; }
  .spacer{flex:1}
</style>
</head>
<body>
  <div id="ui" aria-label="Controls">
    <h3 style="margin:0 0 6px 0">VR Extrude Sequencer</h3>
    <div class="small">원본 1개 + 조각 최대 20개 | 순차/교대 재생 | VR 지원</div>

    <label>원본 이미지 (항상 1개만 유지, 새로 올리면 교체)</label>
    <input id="baseFile" type="file" accept="image/*">

    <label>추가 이미지(조각) 업로드 — 여러 개 선택 가능, 최대 20개까지 누적</label>
    <input id="piecesFiles" type="file" accept="image/*" multiple>

    <div class="row">
      <button id="btnPlaceAll" class="ghost">Align(원본과 해상도 동일 시 중앙정렬)</button>
      <button id="btnClear" class="ghost">조각 모두 삭제</button>
      <div class="spacer"></div>
      <div class="small">업로드된 조각 목록</div>
    </div>

    <div id="piecesList" aria-live="polite"></div>

    <label>Extrusion / Fade</label>
    <div class="sliderRow">
      <div class="small">깊이(World units)</div>
      <input id="popDepth" type="range" min="0.02" max="1.2" step="0.01" value="0.15">
      <div id="popDepthVal" class="small">0.15</div>
    </div>

    <div class="sliderRow">
      <div class="small">Fade duration (초)</div>
      <input id="fadeDuration" type="range" min="0.1" max="2.5" step="0.05" value="0.5">
      <div id="fadeDurationVal" class="small">0.50s</div>
    </div>

    <label>재생 옵션</label>
    <div class="row">
      <button id="btnPlaySeq" class="primary">Play Sequence (Pieces)</button>
      <label class="small" style="display:flex; align-items:center; gap:6px; margin:0 6px">
        <input id="seqLoop" type="checkbox" checked> Loop
      </label>
      <div class="sliderRow" style="margin-left:4px">
        <div class="small">간격(초)</div>
        <input id="seqInterval" type="range" min="0.1" max="5" step="0.1" value="0.6">
        <div id="seqIntervalVal" class="small">0.60s</div>
      </div>
    </div>

    <div class="row">
      <button id="btnPlayAlternate" class="ghost">Play Alternate (Base↔Pieces)</button>
      <button id="btnStop" class="ghost">Stop</button>
    </div>

    <div class="small" style="margin-top:10px">문제 생기면 DevTools → Console 로그 그대로 보내 주세요.</div>
  </div>

  <button id="enterVrBtn">Enter VR</button>
  <div id="canvasContainer"></div>

<script type="module">
/* === 모듈은 절대 URL(CDN)로 가져옵니다 === */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js';

const container = document.getElementById('canvasContainer');
const piecesListEl = document.getElementById('piecesList');
const enterVrBtn = document.getElementById('enterVrBtn');

let renderer, scene, camera;
let baseMesh = null;
/** pieces: [{id, group, frontPlane, bodyMesh, texture, pixelW, pixelH, filename, thumbURL}] */
let pieces = [];
let animRunning = false;
let xrSession = null;

/* -------------------- Init Three -------------------- */
initThree();
hookUI();
checkWebXRAvailability();

function initThree(){
  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  // outputColorSpace exists in r160
  try{ renderer.outputColorSpace = THREE.SRGBColorSpace; }catch(e){}
  renderer.xr.enabled = true;
  container.appendChild(renderer.domElement);

  // Try to create the VRButton. If it throws, log and continue.
  try {
    const btn = VRButton.createButton(renderer);
    btn.classList.add('webxr-button');
    document.body.appendChild(btn);
  } catch(e){ console.warn('VRButton create error:', e); }

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0d10);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 2000);
  camera.position.set(0,0,1.2);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.9); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(0.5,1,0.5); scene.add(dir);

  window.addEventListener('resize', onWindowResize);
  renderer.setAnimationLoop(()=>{ renderer.render(scene, camera); });
}

async function checkWebXRAvailability(){
  if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
    console.info('WebXR은 보안 컨텍스트(HTTPS)에서만 동작합니다. 로컬 테스트는 http://localhost 사용하세요.');
  }

  if(navigator.xr && navigator.xr.isSessionSupported){
    try{
      const supported = await navigator.xr.isSessionSupported('immersive-vr');
      enterVrBtn.disabled = !supported;
      console.info('immersive-vr supported?', supported);
      if(!supported) console.info('immersive-vr not supported by this device/browser.');
    }catch(e){
      enterVrBtn.disabled = true;
      console.warn('XR availability check failed', e);
    }
  } else {
    enterVrBtn.disabled = true;
    console.info('WebXR API not available in this browser.');
  }
}

/* -------------------- Helpers -------------------- */
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function onWindowResize(){ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
function disposeMaterial(m){ try{ if(m.map) m.map.dispose(); m.dispose(); }catch(e){} }
function makeThumbDataURL(bitmap, targetW=128){
  const sx = targetW;
  const sy = Math.max(1, Math.round(bitmap.height*(targetW/bitmap.width)));
  const c=document.createElement('canvas'); c.width=sx; c.height=sy;
  const ctx=c.getContext('2d'); ctx.clearRect(0,0,sx,sy); ctx.drawImage(bitmap,0,0,sx,sy);
  return c.toDataURL();
}
function cryptoRandomId(){
  try{
    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
  }catch(e){ return String(Date.now()) + Math.random().toString(36).slice(2,8); }
}

async function loadImageBitmap(file){
  try { return await createImageBitmap(file); }
  catch(e){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = ()=> resolve(createImageBitmap(img));
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }
}

/* -------------------- Base Image (항상 1개) -------------------- */
async function setBaseImage(file){
  try{
    const bmp = await loadImageBitmap(file);

    if(baseMesh){
      scene.remove(baseMesh);
      disposeMaterial(baseMesh.material);
      baseMesh.geometry.dispose();
      baseMesh = null;
    }

    const tex = new THREE.Texture(bmp);
    try{ tex.colorSpace = THREE.SRGBColorSpace; }catch(e){}
    tex.needsUpdate = true;

    const W = bmp.width, H = bmp.height;
    const worldLong = 1.6;
    const scale = worldLong / Math.max(W,H);
    const geo = new THREE.PlaneGeometry(W*scale, H*scale);
    const mat = new THREE.MeshStandardMaterial({ map: tex, roughness:0.85, metalness:0.0, side: THREE.DoubleSide, transparent:true, opacity:1 });
    baseMesh = new THREE.Mesh(geo, mat);
    baseMesh.userData = { pixelWidth: W, pixelHeight: H, worldWidth: W*scale, worldHeight: H*scale, scale };
    baseMesh.visible = true;
    scene.add(baseMesh);

    const fitZ = Math.max(W*scale, H*scale) / Math.tan(THREE.MathUtils.degToRad(camera.fov/2));
    camera.position.set(0,0, Math.max(0.8, fitZ*0.7));
  }catch(err){ console.error('setBaseImage error', err); alert('원본 이미지 로드 실패 — 콘솔 확인'); }
}

/* -------------------- Pieces (최대 20개) -------------------- */
async function addPieceFile(file){
  if(pieces.length >= 20){ alert('최대 20개 조각입니다. 일부를 삭제하세요.'); return; }
  try{
    const bmp = await loadImageBitmap(file);
    const tex = new THREE.Texture(bmp);
    try{ tex.colorSpace = THREE.SRGBColorSpace; }catch(e){}
    tex.needsUpdate = true;

    // world size(원본 비례)
    let worldW, worldH;
    if(baseMesh){
      const s = baseMesh.userData.scale;
      worldW = bmp.width  * s;
      worldH = bmp.height * s;
    } else {
      const long = Math.max(bmp.width, bmp.height);
      const s = 1.0/long;
      worldW = bmp.width  * s;
      worldH = bmp.height * s;
    }

    // extrude: 얇은 박스 + 앞면 텍스처
    const depthWorld = parseFloat(document.getElementById('popDepth').value) * (baseMesh ? baseMesh.userData.worldWidth : 1);
    const bodyGeo = new THREE.BoxGeometry(worldW, worldH, Math.max(0.001, depthWorld));
    const bodyMat = new THREE.MeshStandardMaterial({ color:0x111111, roughness:0.95, transparent:true, opacity:1 });
    const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);

    const frontGeo = new THREE.PlaneGeometry(worldW, worldH);
    const frontMat = new THREE.MeshStandardMaterial({ map: tex, transparent:true, alphaTest:0.02, side: THREE.DoubleSide, opacity:1 });
    const frontPlane = new THREE.Mesh(frontGeo, frontMat);
    frontPlane.position.z = (Math.max(0.001, depthWorld))/2 + 0.001;

    const group = new THREE.Group();
    group.add(bodyMesh);
    group.add(frontPlane);
    group.position.set(0,0, 0.001 + pieces.length*0.0004);

    const thumbURL = makeThumbDataURL(bmp, 128);
    const entry = {
      id: cryptoRandomId(), group, frontPlane, bodyMesh, texture: tex,
      pixelW: bmp.width, pixelH: bmp.height, filename: file.name, thumbURL
    };

    pieces.push(entry);
    scene.add(group);
    addPieceListItem(entry);
    refreshOrderBadges();
  }catch(err){ console.error('addPieceFile error', err); alert('조각 처리 중 오류 — 콘솔 확인'); }
}

/* ------- 목록 UI ------- */
function addPieceListItem(entry){
  const div=document.createElement('div'); div.className='pieceRow'; div.id='piece-'+entry.id;

  const order=document.createElement('div'); order.className='orderBadge'; order.textContent='—';
  const img=document.createElement('img'); img.className='thumbSmall'; img.src=entry.thumbURL;

  const meta=document.createElement('div'); meta.className='pieceMeta';
  meta.innerHTML=`<div style="font-weight:700">${entry.filename}</div><div class="small">${entry.pixelW}×${entry.pixelH}</div>`;

  const btns=document.createElement('div'); btns.className='pieceBtns';

  const upBtn=document.createElement('button'); upBtn.textContent='↑'; upBtn.className='ghost';
  upBtn.addEventListener('click', ()=> movePiece(entry.id, -1));

  const downBtn=document.createElement('button'); downBtn.textContent='↓'; downBtn.className='ghost';
  downBtn.addEventListener('click', ()=> movePiece(entry.id, +1));

  const alignBtn=document.createElement('button'); alignBtn.textContent='Align'; alignBtn.className='ghost';
  alignBtn.addEventListener('click', ()=>{
    if(!baseMesh) return alert('원본 업로드 필요');
    if(entry.pixelW===baseMesh.userData.pixelWidth && entry.pixelH===baseMesh.userData.pixelHeight){
      entry.group.position.set(0,0,0.002);
    } else { alert('픽셀 크기 불일치'); }
  });

  const removeBtn=document.createElement('button'); removeBtn.textContent='Remove'; removeBtn.className='ghost';
  removeBtn.addEventListener('click', ()=> removePiece(entry.id));

  btns.appendChild(upBtn); btns.appendChild(downBtn); btns.appendChild(alignBtn); btns.appendChild(removeBtn);

  div.appendChild(order); div.appendChild(img); div.appendChild(meta); div.appendChild(btns);
  piecesListEl.appendChild(div);
}

function refreshOrderBadges(){
  pieces.forEach((p,i)=>{
    const row=document.getElementById('piece-'+p.id);
    const badge=row?.querySelector('.orderBadge');
    if(badge) badge.textContent=String(i+1);
    if(p.group) p.group.position.z = 0.001 + i*0.0004;
  });
}

function movePiece(id, dir){
  const idx=pieces.findIndex(p=>p.id===id);
  const j=idx+dir;
  if(idx<0 || j<0 || j>=pieces.length) return;
  [pieces[idx], pieces[j]] = [pieces[j], pieces[idx]];

  const nodeA = document.getElementById('piece-'+pieces[j].id);
  const nodeB = document.getElementById('piece-'+pieces[idx].id);
  if(nodeA && nodeB){
    if(dir<0){ piecesListEl.insertBefore(nodeA, nodeB); }
    else{ piecesListEl.insertBefore(nodeB, nodeA); }
  }
  refreshOrderBadges();
}

function removePiece(id){
  const idx=pieces.findIndex(p=>p.id===id);
  if(idx===-1) return;
  const e=pieces[idx];
  scene.remove(e.group);
  try{ e.texture?.dispose(); }catch(ex){}
  if(e.bodyMesh && e.bodyMesh.geometry) e.bodyMesh.geometry.dispose();
  if(e.frontPlane && e.frontPlane.geometry) e.frontPlane.geometry.dispose();
  pieces.splice(idx,1);
  const el=document.getElementById('piece-'+id); if(el) el.remove();
  refreshOrderBadges();
}

/* -------------------- 재생(조각만) -------------------- */
async function popAndFadeEntry(entry){
  const fadeDur = parseFloat(document.getElementById('fadeDuration').value) || 0.5;
  const group = entry.group;
  const startZ = group.position.z;
  const extra = 0.12; // 살짝 튀는 감
  const peakZ = startZ + extra;
  const halfMs = fadeDur * 1000;

  entry.frontPlane.material.transparent = true;
  entry.bodyMesh.material.transparent = true;
  entry.frontPlane.material.opacity = 0;
  entry.bodyMesh.material.opacity = 0;

  const t0 = performance.now();
  return new Promise(resolve=>{
    function frame(now){
      const t = now - t0;
      if(t < halfMs){
        const p = t/halfMs; const eased = 1 - Math.pow(1-p,3);
        group.position.z = THREE.MathUtils.lerp(startZ, peakZ, eased);
        const op = THREE.MathUtils.lerp(0,1,eased);
        entry.frontPlane.material.opacity = op;
        entry.bodyMesh.material.opacity = op*0.95;
        requestAnimationFrame(frame);
      } else if(t < 2*halfMs){
        const p = (t-halfMs)/halfMs; const eased = 1 - Math.pow(p,3);
        group.position.z = THREE.MathUtils.lerp(startZ, peakZ, eased);
        const op = THREE.MathUtils.lerp(0,1,eased);
        entry.frontPlane.material.opacity = op;
        entry.bodyMesh.material.opacity = op*0.95;
        requestAnimationFrame(frame);
      } else {
        group.position.z = startZ;
        entry.frontPlane.material.opacity = 1;
        entry.bodyMesh.material.opacity = 1;
        resolve();
      }
    }
    requestAnimationFrame(frame);
  });
}

async function startSequence(){
  if(animRunning) return;
  if(pieces.length===0){ alert('조각을 먼저 업로드하세요.'); return; }
  animRunning = true;

  const loop = document.getElementById('seqLoop').checked;
  const gapSec = parseFloat(document.getElementById('seqInterval').value) || 0.6;

  while(animRunning){
    for(let i=0;i<pieces.length && animRunning;i++){
      await popAndFadeEntry(pieces[i]);
      if(!animRunning) break;
      await sleep(gapSec*1000);
    }
    if(!loop) break;
  }
  animRunning = false;
}

/* -------------------- 교대(원본↔조각) -------------------- */
function setBaseOpacity(op){ if(baseMesh){ baseMesh.material.opacity = op; } }
function setBaseVisible(v){ if(baseMesh){ baseMesh.visible = v; } }
function setPieceOpacity(entry, op){
  entry.frontPlane.material.opacity = op;
  entry.bodyMesh.material.opacity  = Math.min(1, op*0.95);
}
function setPieceVisible(entry, v){ entry.group.visible = v; }

function hideAll(){
  if(baseMesh){ setBaseOpacity(0); setBaseVisible(false); }
  for(const p of pieces){ setPieceOpacity(p, 0); setPieceVisible(p, false); }
}

async function crossFade(fromObj, toObj){
  const fadeDur = parseFloat(document.getElementById('fadeDuration').value) || 0.5;
  const ms = Math.max(50, fadeDur*1000);
  const t0 = performance.now();

  // ensure visible
  if(fromObj){ fromObj.setVisible(true); }
  if(toObj){ toObj.setVisible(true); }

  return new Promise(resolve=>{
    function frame(now){
      const t = now - t0;
      const p = Math.min(1, t/ms);
      const easedIn  = 1 - Math.pow(1-p,3);
      const easedOut = 1 - easedIn;

      if(fromObj){ fromObj.setOpacity(easedOut); }
      if(toObj){   toObj.setOpacity(easedIn);  }

      if(p < 1){ requestAnimationFrame(frame); }
      else {
        if(fromObj){ fromObj.setOpacity(0); fromObj.setVisible(false); }
        if(toObj){   toObj.setOpacity(1); toObj.setVisible(true); }
        resolve();
      }
    }
    requestAnimationFrame(frame);
  });
}

function makeBaseRenderable(){
  return {
    setOpacity: setBaseOpacity,
    setVisible: setBaseVisible
  };
}
function makePieceRenderable(entry){
  return {
    setOpacity: (op)=> setPieceOpacity(entry, op),
    setVisible: (v)=> setPieceVisible(entry, v)
  };
}

async function startAlternate(){
  if(animRunning) return;
  if(!baseMesh){ alert('원본 이미지를 먼저 업로드하세요.'); return; }
  if(pieces.length===0){ alert('조각을 1개 이상 업로드하세요.'); return; }
  animRunning = true;

  const loop = document.getElementById('seqLoop').checked;
  const gapSec = parseFloat(document.getElementById('seqInterval').value) || 0.6;

  const baseR = makeBaseRenderable();

  while(animRunning){
    // 순서: Base → piece[0] → Base → piece[1] → ...
    for(let i=0;i<pieces.length && animRunning;i++){
      const pieceR = makePieceRenderable(pieces[i]);

      // 1) Base 보여주기 (이전 항목이 있다면 Cross-fade)
      hideAll();
      await crossFade(null, baseR);         // 처음은 fromObj 없음 → Base fade-in
      if(!animRunning) break;
      await sleep(gapSec*1000);

      // 2) 해당 조각으로 교차
      await crossFade(baseR, pieceR);
      if(!animRunning) break;
      await sleep(gapSec*1000);
    }
    if(!loop) break;
  }

  // 종료 시에는 Base만 남겨 두기
  hideAll();
  setBaseVisible(true); setBaseOpacity(1);

  animRunning = false;
}

/* -------------------- Wire UI -------------------- */
function hookUI(){
  const popDepth = document.getElementById('popDepth');
  const popDepthVal = document.getElementById('popDepthVal');
  popDepth.addEventListener('input', ()=> popDepthVal.textContent = (+popDepth.value).toFixed(2));

  const fadeDuration = document.getElementById('fadeDuration');
  const fadeDurationVal = document.getElementById('fadeDurationVal');
  fadeDuration.addEventListener('input', ()=> fadeDurationVal.textContent = (+fadeDuration.value).toFixed(2)+'s');

  const seqInterval = document.getElementById('seqInterval');
  const seqIntervalVal = document.getElementById('seqIntervalVal');
  seqInterval.addEventListener('input', ()=> seqIntervalVal.textContent = (+seqInterval.value).toFixed(2)+'s');

  document.getElementById('baseFile').addEventListener('change', async (e)=>{
    const f=e.target.files && e.target.files[0];
    if(!f) return;
    await setBaseImage(f);
    e.target.value='';
  });

  document.getElementById('piecesFiles').addEventListener('change', async (e)=>{
    const list = Array.from(e.target.files || []);
    for(const f of list){ if(pieces.length>=20){ alert('최대 20개 제한'); break; } await addPieceFile(f); }
    e.target.value='';
  });

  document.getElementById('btnPlaceAll').addEventListener('click', ()=>{
    if(!baseMesh) return alert('원본 업로드 필요');
    const bw=baseMesh.userData.pixelWidth, bh=baseMesh.userData.pixelHeight;
    for(const p of pieces){
      if(p.pixelW===bw && p.pixelH===bh) p.group.position.set(0,0,0.002);
    }
  });

  document.getElementById('btnClear').addEventListener('click', ()=>{
    for(const p of pieces){ scene.remove(p.group); try{ p.texture?.dispose(); }catch(e){} }
    pieces=[]; piecesListEl.innerHTML=''; refreshOrderBadges();
  });

  document.getElementById('btnPlaySeq').addEventListener('click', ()=> startSequence());
  document.getElementById('btnPlayAlternate').addEventListener('click', ()=> startAlternate());
  document.getElementById('btnStop').addEventListener('click', ()=> { animRunning=false; });

  document.getElementById('enterVrBtn').addEventListener('click', async ()=>{
    // If already presenting, end session
    if(renderer.xr.isPresenting){
      try{ await xrSession?.end(); }catch(e){ console.warn('session end failed', e); }
      return;
    }

    if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
      alert('WebXR은 보안 컨텍스트(HTTPS)에서만 동작합니다. 서버로 띄우거나 localhost로 테스트하세요.');
      return;
    }

    if(!navigator.xr || !navigator.xr.requestSession){ alert('WebXR 미지원 (navigator.xr.requestSession 없음)'); return; }
    try{
      const supported = await navigator.xr.isSessionSupported('immersive-vr');
      if(!supported){ alert('immersive-vr 미지원'); console.info('isSessionSupported returned false'); return; }

      // dom-overlay는 일부 환경에서 session 요청을 거부하므로 기본적으로 제거.
      // 필요하면 별도 브라우저별 처리를 추가하세요.
      const session = await navigator.xr.requestSession('immersive-vr', {
        optionalFeatures: ['local-floor', 'bounded-floor']
      });

      xrSession = session;
      renderer.xr.setSession(session);
      enterVrBtn.textContent='Exit VR';
      console.info('XR session started:', session);

      session.addEventListener('end', ()=>{
        enterVrBtn.textContent='Enter VR'; xrSession=null;
        console.info('XR session ended');
      });

    }catch(err){
      console.error('requestSession failed', err);
      alert('VR 시작 실패 — 콘솔 확인');
    }
  });
}
</script>
</body>
</html>